# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.4.5, generator: @autorest/python@5.8.1)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class ModulesOperations:
    """ModulesOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.iot.gateway.service.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def get_twin(
        self,
        id: str,
        mid: str,
        **kwargs: Any
    ) -> "_models.Twin":
        """Gets the module twin. See
        https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-device-twins for more information.

        :param id: The unique identifier of the device.
        :type id: str
        :param mid: The unique identifier of the module.
        :type mid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Twin, or the result of cls(response)
        :rtype: ~azure.iot.gateway.service.models.Twin
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Twin"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2021-06-30-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_twin.metadata['url']  # type: ignore
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
            'mid': self._serialize.url("mid", mid, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Twin', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_twin.metadata = {'url': '/twins/{id}/modules/{mid}'}  # type: ignore

    async def replace_twin(
        self,
        id: str,
        mid: str,
        device_twin_info: "_models.Twin",
        if_match: Optional[str] = None,
        **kwargs: Any
    ) -> "_models.Twin":
        """Replaces the tags and desired properties of a module twin. See
        https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-device-twins for more information.

        :param id: The unique identifier of the device.
        :type id: str
        :param mid: The unique identifier of the module.
        :type mid: str
        :param device_twin_info: The module twin info that will replace the existing info.
        :type device_twin_info: ~azure.iot.gateway.service.models.Twin
        :param if_match: The string representing a weak ETag for the device twin, as per RFC7232. It
         determines if the replace operation should be carried out.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Twin, or the result of cls(response)
        :rtype: ~azure.iot.gateway.service.models.Twin
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Twin"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2021-06-30-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.replace_twin.metadata['url']  # type: ignore
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
            'mid': self._serialize.url("mid", mid, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(device_twin_info, 'Twin')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Twin', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    replace_twin.metadata = {'url': '/twins/{id}/modules/{mid}'}  # type: ignore

    async def update_twin(
        self,
        id: str,
        mid: str,
        device_twin_info: "_models.Twin",
        if_match: Optional[str] = None,
        **kwargs: Any
    ) -> "_models.Twin":
        """Updates the tags and desired properties of a module twin. See
        https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-device-twins for more information.

        :param id: The unique identifier of the device.
        :type id: str
        :param mid: The unique identifier of the module.
        :type mid: str
        :param device_twin_info: The module twin info containing the tags and desired properties to be
         updated.
        :type device_twin_info: ~azure.iot.gateway.service.models.Twin
        :param if_match: The string representing a weak ETag for the device twin, as per RFC7232. It
         determines if the update operation should be carried out.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Twin, or the result of cls(response)
        :rtype: ~azure.iot.gateway.service.models.Twin
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Twin"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2021-06-30-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_twin.metadata['url']  # type: ignore
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
            'mid': self._serialize.url("mid", mid, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(device_twin_info, 'Twin')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Twin', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_twin.metadata = {'url': '/twins/{id}/modules/{mid}'}  # type: ignore

    async def get_modules_on_device(
        self,
        id: str,
        **kwargs: Any
    ) -> List["_models.Module"]:
        """Gets all the module identities on the device.

        :param id: The unique identifier of the device.
        :type id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of Module, or the result of cls(response)
        :rtype: list[~azure.iot.gateway.service.models.Module]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["_models.Module"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2021-06-30-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_modules_on_device.metadata['url']  # type: ignore
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('[Module]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_modules_on_device.metadata = {'url': '/devices/{id}/modules'}  # type: ignore

    async def get_identity(
        self,
        id: str,
        mid: str,
        **kwargs: Any
    ) -> "_models.Module":
        """Gets a module identity on the device.

        :param id: The unique identifier of the device.
        :type id: str
        :param mid: The unique identifier of the module.
        :type mid: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Module, or the result of cls(response)
        :rtype: ~azure.iot.gateway.service.models.Module
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Module"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2021-06-30-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_identity.metadata['url']  # type: ignore
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
            'mid': self._serialize.url("mid", mid, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Module', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_identity.metadata = {'url': '/devices/{id}/modules/{mid}'}  # type: ignore

    async def create_or_update_identity(
        self,
        id: str,
        mid: str,
        module: "_models.Module",
        if_match: Optional[str] = None,
        **kwargs: Any
    ) -> "_models.Module":
        """Creates or updates the module identity for a device in the IoT Hub. The moduleId and
        generationId cannot be updated by the user.

        :param id: The unique identifier of the device.
        :type id: str
        :param mid: The unique identifier of the module.
        :type mid: str
        :param module: The module identity.
        :type module: ~azure.iot.gateway.service.models.Module
        :param if_match: The string representing a weak ETag for the module, as per RFC7232. This
         should not be set when creating a module, but may be set when updating a module.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Module, or the result of cls(response)
        :rtype: ~azure.iot.gateway.service.models.Module
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Module"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2021-06-30-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_or_update_identity.metadata['url']  # type: ignore
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
            'mid': self._serialize.url("mid", mid, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(module, 'Module')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize('Module', pipeline_response)

        if response.status_code == 201:
            deserialized = self._deserialize('Module', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_identity.metadata = {'url': '/devices/{id}/modules/{mid}'}  # type: ignore

    async def delete_identity(
        self,
        id: str,
        mid: str,
        if_match: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Deletes the module identity for a device in the IoT Hub.

        :param id: The unique identifier of the deivce.
        :type id: str
        :param mid: The unique identifier of the module.
        :type mid: str
        :param if_match: The string representing a weak ETag for the module, as per RFC7232. The delete
         operation is performed only if this ETag matches the value maintained by the server, indicating
         that the module has not been modified since it was last retrieved. To force an unconditional
         delete, set If-Match to the wildcard character (*).
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2021-06-30-preview"

        # Construct URL
        url = self.delete_identity.metadata['url']  # type: ignore
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
            'mid': self._serialize.url("mid", mid, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_identity.metadata = {'url': '/devices/{id}/modules/{mid}'}  # type: ignore

    async def invoke_method(
        self,
        device_id: str,
        module_id: str,
        direct_method_request: "_models.CloudToDeviceMethod",
        **kwargs: Any
    ) -> "_models.CloudToDeviceMethodResult":
        """Invokes a direct method on a module of a device. See
        https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-direct-methods for more information.

        :param device_id: The unique identifier of the device.
        :type device_id: str
        :param module_id: The unique identifier of the module.
        :type module_id: str
        :param direct_method_request: The parameters to execute a direct method on the module.
        :type direct_method_request: ~azure.iot.gateway.service.models.CloudToDeviceMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CloudToDeviceMethodResult, or the result of cls(response)
        :rtype: ~azure.iot.gateway.service.models.CloudToDeviceMethodResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CloudToDeviceMethodResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2021-06-30-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.invoke_method.metadata['url']  # type: ignore
        path_format_arguments = {
            'deviceId': self._serialize.url("device_id", device_id, 'str'),
            'moduleId': self._serialize.url("module_id", module_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(direct_method_request, 'CloudToDeviceMethod')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CloudToDeviceMethodResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    invoke_method.metadata = {'url': '/twins/{deviceId}/modules/{moduleId}/methods'}  # type: ignore
